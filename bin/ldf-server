#!/usr/bin/env node
/*! @license MIT Â©2013-2017 Ruben Verborgh and Ruben Taelman, Ghent University - imec */
/* Standalone Linked Data Fragments Server */

var _ = require('lodash'),
    fs = require('fs'),
    path = require('path'),
    cluster = require('cluster'),
    components = require('lsd-components'),
    ComponentRunner = components.ComponentRunner,
    JsonLdStreamParser = components.JsonLdStreamParser,
    JsonLdStreamer = components.JsonLdStreamer;

// Parse arguments
var args = process.argv.slice(2);
if (args.length < 1 || args.length > 3 || /^--?h(elp)?$/.test(args[0])) {
  console.log('usage: server config.json [port [workers]]');
  return process.exit(1);
}
// TODO: for now we only support JSON-LD. Improve this so we accept any kind of RDF syntax.
var configDefaults = JSON.parse(fs.readFileSync(path.join(__dirname, '../config/config-defaults.json'))),
    config = _.defaults(JSON.parse(fs.readFileSync(args[0])), configDefaults),
    port = parseInt(args[1], 10) || config['ldfs:port'],
    workers = parseInt(args[2], 10) || config['ldfs:workers'],
    protocolMatch = (config['ldfs:baseURL'] || '').match(/^(\w+):/),
    protocol = config.protocol = protocolMatch ? protocolMatch[1] : 'http';
// Merge JSON-LD contexts
config['@context'] = _.defaults(config['@context'], configDefaults['@context']);

// Start up a cluster master
if (cluster.isMaster) {
  // Create workers
  console.log('Master %d running on %s://localhost:%d/.', process.pid, protocol, port);
  for (var i = 0; i < workers; i++)
    cluster.fork();

  // Respawn crashed workers
  cluster.on('listening', function (worker) {
    worker.once('exit', function (code, signal) {
      if (!worker.suicide) {
        console.log('Worker %d died with %s. Starting new worker.',
                    worker.process.pid, code || signal);
        cluster.fork();
      }
    });
  });

  // Respawn workers one by one when receiving a SIGHUP signal
  process.on('SIGHUP', function respawn() {
    console.log('Respawning workers of master %d.', process.pid);
    process.addListener('SIGHUP', respawnPending);
    process.removeListener('SIGHUP', respawn);

    // Retrieve a list of old workers that will be replaced by new ones
    var workers = Object.keys(cluster.workers).map(function (id) { return cluster.workers[id]; });
    (function respawnNext() {
      // If there are still old workers, respawn a new one
      if (workers.length) {
        // Wait until the new worker starts listening to kill the old one
        var newWorker = cluster.fork();
        newWorker.once('listening', function () {
          var worker = workers.pop();
          if (!worker)
            return newWorker.kill(), respawnNext(); // Dead workers are replaced automatically
          worker.once('exit', function () {
            console.log('Worker %d replaces killed worker %d.',
                        newWorker.process.pid, worker.process.pid);
            respawnNext();
          });
          worker.kill();
          newWorker.removeListener('exit', abort);
        });
        // Abort the respawning process if creating a new worker fails
        newWorker.on('exit', abort);
        function abort(code, signal) {
          if (!newWorker.suicide) {
            console.log('Respawning aborted because worker %d died with %s.',
                        newWorker.process.pid, code || signal);
            process.addListener('SIGHUP', respawn);
            process.removeListener('SIGHUP', respawnPending);
          }
        }
      }
      // No old workers left, so respawning has finished
      else {
        process.addListener('SIGHUP', respawn);
        process.removeListener('SIGHUP', respawnPending);
        console.log('Respawned all workers of master %d.', process.pid);
      }
    })();
    function respawnPending() { console.log('Respawning already in progress'); }
  });
}
// Start up a worker
else {
  var runner = new ComponentRunner();
  var moduleStream = fs.createReadStream(path.join(__dirname, '/../components.json')).pipe(new JsonLdStreamParser());
  var configStream = new JsonLdStreamer(config);
  runner.overrideRequireNames['ldf-server'] = path.join(__dirname, '/../module.js'); // TODO: Hack!
  runner.registerModuleResourcesStream(moduleStream)
    .then(function () {
      // TODO: detect config URI at runtime.
      return runner.runConfigStream('http://localhost:3000/', configStream);
    })
    .catch(function (e) {
      console.error(e);
      process.exit(1);
    });
}
